<!doctype html>
<html lang="en-us">
  <head>
    <title>手撕HashMap(Jdk8) // 阿强的blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="wangqiang" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://ko1a.github.io/css/main.min.4c1a909e6fe10d8fe1d9033af603c9b9a7803efa8046860032882a48f84a40f1.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="手撕HashMap(Jdk8)"/>
<meta name="twitter:description" content="概述 今天我们来聊聊,我们日常开发中最常用的一个集合类:HashMap,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.
 一、基础知识   数组
数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.
优点:
 可以保存若干个数据 随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。  缺点:
 数组的元素的类型必须一致 数组定长，不能自动扩容 删除元素、插入元素效率比较低，需要移动大量的元素    链表
链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址
图是单链表
优点:
 任意加减元素 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可 添加，删除效率高  缺点:
 因为含有大量的指针域，占用空间较大 查找元素需要遍历链表来查找    散列表
散列表结构基于 数组&#43;链表 ,整合了数组的快速索引和链表的动态扩容的优势
  什么是哈希(hash)
hash 也成散列,哈希,基本原理就是把任意长度的输入,通过hash算法变成固定长度的输出.这个映射规则就是对应的hash算法,原始数据映射后的二进制串就是哈希值(hashCode)
特点:
  从hash值不能反向推导出原始数据
  输入的数据微小变化会得到完全不同的hash值,相同的数据会得到相同的hash值
  hash算法的执行效率高,长文本也能快速计算hash值
  hash算法的冲突概率要小
   hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间
比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理
  二、基本原理 存储结构 结构实现来讲，HashMap是数组&#43;链表&#43;红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。
HashMap 使用拉链式的散列算法,其数据结构是由数组和链表（或树形结构）组成。"/>

    <meta property="og:title" content="手撕HashMap(Jdk8)" />
<meta property="og:description" content="概述 今天我们来聊聊,我们日常开发中最常用的一个集合类:HashMap,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.
 一、基础知识   数组
数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.
优点:
 可以保存若干个数据 随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。  缺点:
 数组的元素的类型必须一致 数组定长，不能自动扩容 删除元素、插入元素效率比较低，需要移动大量的元素    链表
链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址
图是单链表
优点:
 任意加减元素 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可 添加，删除效率高  缺点:
 因为含有大量的指针域，占用空间较大 查找元素需要遍历链表来查找    散列表
散列表结构基于 数组&#43;链表 ,整合了数组的快速索引和链表的动态扩容的优势
  什么是哈希(hash)
hash 也成散列,哈希,基本原理就是把任意长度的输入,通过hash算法变成固定长度的输出.这个映射规则就是对应的hash算法,原始数据映射后的二进制串就是哈希值(hashCode)
特点:
  从hash值不能反向推导出原始数据
  输入的数据微小变化会得到完全不同的hash值,相同的数据会得到相同的hash值
  hash算法的执行效率高,长文本也能快速计算hash值
  hash算法的冲突概率要小
   hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间
比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理
  二、基本原理 存储结构 结构实现来讲，HashMap是数组&#43;链表&#43;红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。
HashMap 使用拉链式的散列算法,其数据结构是由数组和链表（或树形结构）组成。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ko1a.github.io/post/blog2hashmap/" />
<meta property="article:published_time" content="2020-06-19T13:20:17+08:00" />
<meta property="article:modified_time" content="2020-06-19T13:20:17+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://ko1a.github.io/"><img class="app-header-avatar" src="https://pic4.zhimg.com/80/v2-2f47aaadf2eef73c77a4497a67181854_1440w.jpg?source=1940ef5c" alt="wangqiang" /></a>
      <h1>阿强的blog</h1>
      <p>go for it</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">手撕HashMap(Jdk8)</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 19, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          10 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://ko1a.github.io/tags/java/">Java</a>
              <a class="tag" href="https://ko1a.github.io/tags/hashmap/">hashMap</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="概述">概述</h2>
<p>今天我们来聊聊,我们日常开发中最常用的一个集合类:<!-- raw HTML omitted -->HashMap<!-- raw HTML omitted -->,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.</p>
<p> </p>
<h3 id="一基础知识">一、基础知识</h3>
<ol>
<li>
<p><strong>数组</strong></p>
<p>数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.</p>
<p><img src="/images/image-20210221153520150.png" alt=""></p>
<p><strong>优点</strong>:</p>
<ul>
<li>可以保存若干个数据</li>
<li>随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>数组的元素的类型必须一致</li>
<li>数组定长，不能自动扩容</li>
<li>删除元素、插入元素效率比较低，需要移动大量的元素</li>
</ul>
</li>
<li>
<p><strong>链表</strong></p>
<p>链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址</p>
<p>图是单链表</p>
<p><img src="/images/image-20210221160024293.png" alt="image-20210221160024293"></p>
<p><strong>优点</strong>:</p>
<ul>
<li>任意加减元素</li>
<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可</li>
<li>添加，删除效率高</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>因为含有大量的指针域，占用空间较大</li>
<li>查找元素需要遍历链表来查找</li>
</ul>
</li>
<li>
<p><strong>散列表</strong></p>
<p>散列表结构基于 数组+链表 ,整合了数组的快速索引和链表的动态扩容的优势</p>
<p><img src="/images/image-20210221160945491.png" alt=""></p>
</li>
<li>
<p><strong>什么是哈希(hash)</strong></p>
<p>hash 也成散列,哈希,基本原理就是把<!-- raw HTML omitted --><strong>任意长度</strong><!-- raw HTML omitted -->的输入,通过hash算法变成<!-- raw HTML omitted --><strong>固定长度</strong><!-- raw HTML omitted -->的输出.这个映射规则就是对应的<!-- raw HTML omitted --><strong>hash算法</strong><!-- raw HTML omitted -->,原始数据映射后的<!-- raw HTML omitted --><strong>二进制串</strong><!-- raw HTML omitted -->就是哈希值(hashCode)</p>
<p><strong>特点</strong>:</p>
<ul>
<li>
<p>从hash值不能<!-- raw HTML omitted --><strong>反向推导</strong><!-- raw HTML omitted -->出原始数据</p>
</li>
<li>
<p>输入的数据<!-- raw HTML omitted --><strong>微小变化</strong><!-- raw HTML omitted -->会得到完全不同的hash值,相同的数据会得到相同的hash值</p>
</li>
<li>
<p>hash算法的执行效率高,长文本也能快速计算hash值</p>
</li>
<li>
<p>hash算法的冲突概率要小</p>
<p> </p>
</li>
</ul>
<p>hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间</p>
<p>比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:<strong>抽屉原理</strong></p>
</li>
</ol>
<h3 id="二基本原理">二、基本原理</h3>
<h4 id="存储结构">存储结构</h4>
<p>结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="/images/3169099812-5a65971be70a6_articlex.png" alt="img"></p>
<p>HashMap 使用拉链式的散列算法,其数据结构是由数组和链表（或树形结构）组成。</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部(JDK1.7是采用头插法,插在头部)。</p>
<p>当一个链表的元素个数达到一定的数量且数组的长度达到一定的长度后，则把链表转化为红黑树。</p>
<h3 id="三源码分析">三、源码分析</h3>
<p>打开<code>HashMap.java</code> 来瞧一瞧</p>
<h4 id="类成员">类成员</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> AbstractMap<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;,</span> Cloneable<span style="color:#f92672">,</span> Serializable <span style="color:#f92672">{</span>
	<span style="color:#75715e">/**
</span><span style="color:#75715e">     *	默认的初始化容量16,hashMap的容量必须是2的次方数.
</span><span style="color:#75715e">     *	1&lt;&lt;4=16  这里是0000 0001 左移4位变成0001 0000 转换成十进制等于16 (看不懂的请先看我另外&lt;&lt;java位运算&gt;&gt;这篇文章)
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_INITIAL_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 4<span style="color:#f92672">;</span> <span style="color:#75715e">// aka 16
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	最大的容量为2的30次方  
</span><span style="color:#75715e">     *	算了一下是:1073741824
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAXIMUM_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 30<span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	默认负载因子
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> DEFAULT_LOAD_FACTOR <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">75f</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	链表转成红黑树的阈值(条件1)
</span><span style="color:#75715e">     *	hash碰撞之后,形成链表,当链表长度超过这个值得时候,有可能进行链表到红黑树的转变
</span><span style="color:#75715e">     *	转换成红黑树必须要满足两个条件
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TREEIFY_THRESHOLD <span style="color:#f92672">=</span> 8<span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	红黑树转为链表的阈值。
</span><span style="color:#75715e">     * 	比如:在删除某些元素之后,扩容时如果发现链表长度(桶中元素个数)小于 6，则会由红黑树重新退化为链表
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> UNTREEIFY_THRESHOLD <span style="color:#f92672">=</span> 6<span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	最小树化容量阈值(条件2)
</span><span style="color:#75715e">     *	当哈希表中的容量(数组的长度) &gt; 该值时，才允许树形化链表,否则，若桶内元素太多时，则直接扩容，而不是树形化
</span><span style="color:#75715e">     *	为了避免进行扩容和树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
</span><span style="color:#75715e">     *	转换成红黑树必须要满足两个条件
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MIN_TREEIFY_CAPACITY <span style="color:#f92672">=</span> 64<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Node 是 hashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射 (键值对)
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">;</span> <span style="color:#75715e">// 用来定位数组索引位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">final</span> K key<span style="color:#f92672">;</span>
        V value<span style="color:#f92672">;</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span> <span style="color:#75715e">// 链表的下一个node
</span><span style="color:#75715e"></span>
        Node<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> K <span style="color:#a6e22e">getKey</span><span style="color:#f92672">()</span>        <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span>      <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>V newValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
		<span style="color:#75715e">/**
</span><span style="color:#75715e">     * 哈希桶数组，分配的时候，table的长度总是2的次方数
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> table<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * HashMap 中实际存储的 key-value 键值对数量
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败机制
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> modCount<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * HashMap 扩容阈值，当数量&gt;=threshold时，就会扩容
</span><span style="color:#75715e">     * 计算方法：容量capacity * 负载因子load factor    
</span><span style="color:#75715e">     * 比如:默认容量16*0.75=12,当map中的元素&gt;=12 就会触发扩容
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * HashMap 的负载因子.作用是为了计算扩容阈值
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="构造方法">构造方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法1:定了具体容量大小和加载因子的构造函数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  	<span style="color:#75715e">//校验:传入的初始化容量参数不能&lt;0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal initial capacity: &#34;</span> <span style="color:#f92672">+</span>
                                         initialCapacity<span style="color:#f92672">);</span>
  	<span style="color:#75715e">//校验:如果传入的初始化容量参数&gt;MAXIMUM_CAPACITY最大容量值,就把最大值赋值给初始化容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&gt;</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span>
      initialCapacity <span style="color:#f92672">=</span> MAXIMUM_CAPACITY<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//校验:负载因子不能&lt;=0 并且 它不能是个非数值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>loadFactor <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">||</span> Float<span style="color:#f92672">.</span><span style="color:#a6e22e">isNaN</span><span style="color:#f92672">(</span>loadFactor<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal load factor: &#34;</span> <span style="color:#f92672">+</span>
                                         loadFactor<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> loadFactor<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//这个方法下面会讲到
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">threshold</span> <span style="color:#f92672">=</span> tableSizeFor<span style="color:#f92672">(</span>initialCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法2:指定了具体容量大小的构造函数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  	<span style="color:#75715e">//调用上面那个方法,传入的是默认负载因子
</span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>initialCapacity<span style="color:#f92672">,</span> DEFAULT_LOAD_FACTOR<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法3:默认无参构造
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> DEFAULT_LOAD_FACTOR<span style="color:#f92672">;</span> <span style="color:#75715e">// all other fields defaulted
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法4:指定map
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">(</span>Map<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> K<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> V<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> DEFAULT_LOAD_FACTOR<span style="color:#f92672">;</span>
    putMapEntries<span style="color:#f92672">(</span>m<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="tablesizefor">tableSizeFor</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Returns a power of two size for the given target capacity.
</span><span style="color:#75715e"> * 计算出 &gt;=cap的最小的2的次方数
</span><span style="color:#75715e"> * 例如:cap=10 ,那么最接近10的2的次方数是16
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tableSizeFor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> cap<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> cap <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 8<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> MAXIMUM_CAPACITY <span style="color:#f92672">:</span> n <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>


</code></pre></div><p>这里看不懂的请看我的另外一片文章:<a href="https://ko1a.github.io/post/bitoperationblog/">&laquo;Java中位运算&raquo;</a></p>
<p>举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>		<span style="color:#75715e">//10的二进制:0000 0000 0000 0000 0000 0000 0000 1010
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 10 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>	<span style="color:#75715e">//9的二进制: 0000 0000 0000 0000 0000 0000 0000 1001
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">;</span> 
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1001&gt;&gt;&gt;1等于0000 0000 0000 0000 0000 0000 0000 0100 
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1001 | 0000 0000 0000 0000 0000 0000 0000 0100
</span><span style="color:#75715e">//		n=0000 0000 0000 0000 0000 0000 0000 1101
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1101&gt;&gt;&gt;2等于0000 0000 0000 0000 0000 0000 0000 0011
</span><span style="color:#75715e">//第二步:0000 0000 0000 0000 0000 0000 0000 1101 | 0000 0000 0000 0000 0000 0000 0000 0011
</span><span style="color:#75715e">//		n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1111&gt;&gt;&gt;4等于0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e">//右移4位还是1111
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 8<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1111&gt;&gt;&gt;8等于0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e">//右移8位还是1111
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1111&gt;&gt;&gt;16等于0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e">//右移16位还是1111
</span><span style="color:#75715e">//1111转出十进制就是15
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//如果计算出来n&lt;最大容量 n+1
</span><span style="color:#75715e">//n=15+1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> MAXIMUM_CAPACITY <span style="color:#f92672">:</span> n <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>



</code></pre></div><p>最后 <code>int n = cap - 1;</code> 这个是为了你传入的cap就是2的次方数.</p>
<p>例如8 那么算出来的结果就会是16. 那么就翻了一倍&hellip;可以自己尝试一下就明白了</p>
<h4 id="put方法">put方法</h4>
<p>虽然插入的入口是put, 但是核心逻辑在putVal 里面</p>
<p>源码↓↓↓</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> putVal<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 扰动函数:更新新数据的key 先 hashCode 在将hash值进行右移16位后 再与原hash值 进行异或操作 
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> h<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">())</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * int hash key计算出来的hash值
</span><span style="color:#75715e"> * K key 
</span><span style="color:#75715e"> * V value
</span><span style="color:#75715e"> * boolean onlyIfAbsent 是否覆盖
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">,</span>
                   <span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  			<span style="color:#75715e">//临时变量 
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//tab 当前散列表
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//p	待插入位置的元素
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//n hash 数组的长度
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//i 插入元素在数组中的下标位置
</span><span style="color:#75715e"></span>        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">;</span>
  			<span style="color:#75715e">//先赋值,然后判断hashMap是否是空,如果是,调用resize()方法扩容.懒加载机制
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
            n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> resize<span style="color:#f92672">()).</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
  
        <span style="color:#75715e">/**
</span><span style="color:#75715e">        * ①:i = (n - 1) &amp; hash 计算出新数据插入位置的下标,赋值给i
</span><span style="color:#75715e">        * ②:将i的位置的数据,赋值给p
</span><span style="color:#75715e">        *	③:判断p是否为null,如果是null ,则直接插入
</span><span style="color:#75715e">        */</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            tab<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
  			<span style="color:#75715e">//否则p不为null的情况
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
          	<span style="color:#75715e">//先定义临时变量,e,k
</span><span style="color:#75715e"></span>            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span> K k<span style="color:#f92672">;</span>
          	<span style="color:#75715e">//判断p的hash是否是新数据的hash 并且 key是否相等,如果是,就把p赋值给e
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                e <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
          	<span style="color:#75715e">//判断p是否是红黑树,如果是,就走插入红黑树的逻辑
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
                e <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>p<span style="color:#f92672">).</span><span style="color:#a6e22e">putTreeVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> tab<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
          	<span style="color:#75715e">//否则,p不等于要插入的新元素,就开始拉链插入
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">//循环
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> binCount <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> <span style="color:#f92672">;</span> <span style="color:#f92672">++</span>binCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                  <span style="color:#75715e">//将p.next节点赋值给e,并判断是否为空,是直接插入,
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                      <span style="color:#75715e">//判断链表的长度&gt;树化的阈值,就有可能树化转红黑树,treeifyBin方法里面会判断数组长度是否&gt;=64,
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">&gt;=</span> TREEIFY_THRESHOLD <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#75715e">// -1 for 1st
</span><span style="color:#75715e"></span>                            treeifyBin<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> hash<span style="color:#f92672">);</span>
                        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                  <span style="color:#75715e">//如果e跟新元素是一样就直接break
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                        <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                    p <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
          <span style="color:#75715e">//e不等于null,就替换操作,返回老数据
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// existing mapping for key
</span><span style="color:#75715e"></span>                V oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent <span style="color:#f92672">||</span> oldValue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                afterNodeAccess<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
  			<span style="color:#75715e">// 更新内部结构发生变化的次数
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
  			<span style="color:#75715e">// 判断 自增后的桶的大小&gt;扩容阈值,则扩容
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>size <span style="color:#f92672">&gt;</span> threshold<span style="color:#f92672">)</span>
            resize<span style="color:#f92672">();</span>
        afterNodeInsertion<span style="color:#f92672">(</span>evict<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p><strong>插入逻辑分析:</strong></p>
<ol>
<li><strong>先判断hashMap是否为null,是的话,就进行初始化操作(懒加载)</strong></li>
<li><strong>计算插入位置的下标,判断为null,如果是null就直接插入</strong></li>
<li><strong>判断插入位置的引用是否是红黑树,如果是就走红黑树插入逻辑,否则就是链表</strong></li>
<li><strong>循环链表,判断链表长度是否达到树化阈值,若果达到,继续判断数组长度是否大于64,两个判断同时成立,转换成红黑树,否则继续扩容,判断插入数据是否相等则替换,否则将其插入尾部(jdk7是采用头插法)</strong></li>
<li><strong>更新内部结构发生变化的次数和判断是否扩容.</strong></li>
</ol>
<p>几个细节分析:</p>
<p>① 在计算hash,这里为什么要先后移16位,再进行异或操作?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">())</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">)</span>
</code></pre></div><p>举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">h<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span> <span style="color:#f92672">=</span>    1010 0100 1101 1110 0101 1011 1011 0001
h<span style="color:#f92672">=</span>              1010 0101 1101 1110 0101 1011 1011 0001
h<span style="color:#f92672">&gt;&gt;&gt;</span>16 <span style="color:#f92672">=</span>        0000 0000 0000 0000 0010 0100 1101 1110
h <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">)=</span> 1010 0101 1101 1110 0111 1111 0110 1111
<span style="color:#75715e">//假设这里不右移
</span><span style="color:#75715e"></span>h<span style="color:#f92672">=</span>              1010 0101 1101 1110 0101 1011 1011 0001
h<span style="color:#f92672">^</span>h<span style="color:#f92672">=</span>            0000 0000 0000 0000 0010 0100 1101 1110
<span style="color:#75715e">//所以可以看出有什么区别吧...
</span><span style="color:#75715e"></span>
</code></pre></div><p><strong>右移16位.再进行了异或操作后,是为了让高位和低位同时参与hash计算,增加hash的复杂度.其目的就是可以提高hash的散列性,从而减少hash碰撞.</strong></p>
<p>②计算下标</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash
</code></pre></div><p>这行代码效果就是根据hash值算出来一个数组下标</p>
<p>举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//假设hash = 阿强
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;阿强&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">();</span>
<span style="color:#75715e">//假设数组的长度是16
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>
n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span><span style="color:#75715e">//n-1是因为数组下标从0开始
</span><span style="color:#75715e">// hash 转换成二进制:100101001000011011011
</span><span style="color:#75715e">// n    转换成二进制:000000000000000001111
</span><span style="color:#75715e">//进行 &amp; 操作之后结果:000000000000000001011 转换成十进制为:11
</span></code></pre></div><p><strong>因为n的高位都是0 ,&amp;操作之后,低位就和hash的低位是一样的,实际的取值范围就是低四位的取值范围.所以就是0000到1111.</strong></p>
<p><strong>可以看出其实这里就是一个取模的操作,如果数组的length不是2的次方数,用位运算计算的话,会出现不一样的结果,但是位运算效率比取模高.</strong></p>
<p>再举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> 17<span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 15<span style="color:#f92672">;</span>
n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">// hash 转换成二进制:10001
</span><span style="color:#75715e">// n    转换成二进制:01110
</span><span style="color:#75715e">// &amp;    结果:       00000
</span><span style="color:#75715e">//用十进制取余 17%15=2;
</span><span style="color:#75715e">//但是用 位运算 的结果=0
</span></code></pre></div><p><strong>所以,如果是用位运算计算,HashMap的容量一定要是2的次方数</strong></p>
<h4 id="resize-扩容方法">resize 扩容方法</h4>
<p>扩容就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p>
<p>扩容条件:</p>
<ol>
<li>当表为null,初始化扩容</li>
<li>链表长度&gt;=8</li>
<li>hashMap的元素个数 * loadFactor 负载因子(默认0.75) &gt;=threshold 扩容阈值 发生扩容.例:16*0.75=12. 当map中的元素&gt;=12会扩容</li>
</ol>
<p>上源码&hellip;↓↓↓</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  	<span style="color:#75715e">//定义个变量oldTab,把当前的tab赋值给它
</span><span style="color:#75715e"></span>    HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> oldTab <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//定义变量:oldCap ,老tab的容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> oldCap <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>oldTab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> oldTab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
  	<span style="color:#75715e">//老tab的扩容阈值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> oldThr <span style="color:#f92672">=</span> threshold<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//新tab的容量,新tab的扩容阈值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> newCap<span style="color:#f92672">,</span> newThr <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//判断老的tab容量&gt;0,代表这是一次正常的扩容
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldCap <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">//判断老tab的最大容量大于等于tab的最大容量,不扩容
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldCap <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            threshold <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span> oldTab<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
      <span style="color:#75715e">//先将老tab的容量*2赋值给newCap 新tab容量
</span><span style="color:#75715e"></span>      <span style="color:#75715e">//判断 老tab的容量*2 &lt; 最大容量 并且 老容量 &gt;=初始容量,成立:新的扩容阈值=老阈值*2
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>newCap <span style="color:#f92672">=</span> oldCap <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY <span style="color:#f92672">&amp;&amp;</span>
                oldCap <span style="color:#f92672">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span style="color:#f92672">)</span>
            newThr <span style="color:#f92672">=</span> oldThr <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">;</span> <span style="color:#75715e">// double threshold
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
  	<span style="color:#75715e">//否则老容量==0 ,初始化动作
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//并且 老扩容阈值&gt;0 ,那么新的容量=老的阈值
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//这种情况应该是通过 new HashMap(n) 
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldThr <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#75715e">// initial capacity was placed in threshold
</span><span style="color:#75715e"></span>        newCap <span style="color:#f92672">=</span> oldThr<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//都不成立的情况下,也是初始化操作进来的,通过new HashMap();无参构造方法调用,默认为初始值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>               <span style="color:#75715e">// zero initial threshold signifies using defaults
</span><span style="color:#75715e"></span>        newCap <span style="color:#f92672">=</span> DEFAULT_INITIAL_CAPACITY<span style="color:#f92672">;</span>
        newThr <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)(</span>DEFAULT_LOAD_FACTOR <span style="color:#f92672">*</span> DEFAULT_INITIAL_CAPACITY<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
  	<span style="color:#75715e">//如果新的扩容阈值=0,就给他计算一个扩容阈值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newThr <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">float</span> ft <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">float</span><span style="color:#f92672">)</span>newCap <span style="color:#f92672">*</span> loadFactor<span style="color:#f92672">;</span>
        newThr <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>newCap <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY <span style="color:#f92672">&amp;&amp;</span> ft <span style="color:#f92672">&lt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">float</span><span style="color:#f92672">)</span>MAXIMUM_CAPACITY <span style="color:#f92672">?</span>
                <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>ft <span style="color:#f92672">:</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
  <span style="color:#75715e">//新的扩容阈值,赋值给当前扩容阈值
</span><span style="color:#75715e"></span>    threshold <span style="color:#f92672">=</span> newThr<span style="color:#f92672">;</span>
    <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">({</span><span style="color:#e6db74">&#34;rawtypes&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">})</span>
  <span style="color:#75715e">//创建一个新的数组.长度是老的2倍
</span><span style="color:#75715e"></span>    HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> newTab <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">[</span>newCap<span style="color:#f92672">];</span>
  <span style="color:#75715e">//新创建的tab赋值给当前tab
</span><span style="color:#75715e"></span>    table <span style="color:#f92672">=</span> newTab<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldTab <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">//遍历老tab,把老的tab的数据赋值到新的tab
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> oldCap<span style="color:#f92672">;</span> <span style="color:#f92672">++</span>j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">//定义一个临时数据节点 e
</span><span style="color:#75715e"></span>            HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
          <span style="color:#75715e">//判断桶中的第一个元素不为null,并赋值给e
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> oldTab<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">//将老的数据变成null,估计这样做的好处就是方便gc回收吧
</span><span style="color:#75715e"></span>                oldTab<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
              <span style="color:#75715e">//如果第一个元素的下一个节点==null,那么它就不是一个链表.直接赋值给新tab
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    newTab<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>newCap <span style="color:#f92672">-</span> 1<span style="color:#f92672">)]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
              <span style="color:#75715e">//如果是红黑树,就走红黑树的逻辑
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#66d9ef">instanceof</span> HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">TreeNode</span><span style="color:#f92672">)</span>
                    <span style="color:#f92672">((</span>HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">TreeNode</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>e<span style="color:#f92672">).</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> newTab<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> oldCap<span style="color:#f92672">);</span>
              <span style="color:#75715e">//否则就是一个链表
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// preserve order
</span><span style="color:#75715e"></span>                  <span style="color:#75715e">//低位链表
</span><span style="color:#75715e"></span>                    HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> loHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> loTail <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                  <span style="color:#75715e">//高位链表
</span><span style="color:#75715e"></span>                    HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> hiHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> hiTail <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                  <span style="color:#75715e">//下个节点
</span><span style="color:#75715e"></span>                    HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span>
                  <span style="color:#75715e">//循环老的链表,可能将其拆分成两个链表
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
                        next <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
                      <span style="color:#75715e">//通过 hash &amp; 老tab容量的 ==0 就把它放到低位链表里
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> oldCap<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>loTail <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                loHead <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">else</span>
                                loTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            loTail <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                      <span style="color:#75715e">//否则放到高位列表
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hiTail <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                hiHead <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">else</span>
                                hiTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            hiTail <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> next<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                  	<span style="color:#75715e">//前面只是进行组装数据,这里才是真正的赋值
</span><span style="color:#75715e"></span>                  	<span style="color:#75715e">//首先是低位链表赋值,放到原来的位置
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>loTail <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        loTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        newTab<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> loHead<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                  <span style="color:#75715e">//高位链表的下标 = 原来的下标位置+老tab的长度 
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hiTail <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        hiTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        newTab<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> oldCap<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> hiHead<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> newTab<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>扩容逻辑分析:</p>
<ol>
<li>判断是扩容还是初始化</li>
<li>计算出新的tab的容量和扩容阈值</li>
<li>扩容分三种情况:
<ul>
<li>1:无hash碰撞,将数据赋值到新的桶中</li>
<li>2:如果是红黑树,则拆分红黑树</li>
<li>3:如果是个链表,遍历链表节点按原顺序分组</li>
</ul>
</li>
</ol>
<p>具体分组逻辑:</p>
<p>原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加老容量的位置</p>
<p>核心逻辑就是这两行代码:</p>
<p>判断存储位置. 高或低</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span><span style="color:#f92672">((</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> oldCap<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
</code></pre></div><p>计算高位置下标</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">newTab<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> oldCap<span style="color:#f92672">]</span>
</code></pre></div><p>先举个栗子,看完就明白</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//①假设数组的长度16 ,两个hash值
</span><span style="color:#75715e"></span>n<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span>1 <span style="color:#75715e">//二进制:0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e"></span>hash1 <span style="color:#75715e">//     :1101 1001 0100 1000 0110 1001 1011
</span><span style="color:#75715e"></span>hash2 <span style="color:#75715e">//     :1101 1001 0100 1000 0110 1000 1011
</span><span style="color:#75715e"></span><span style="color:#f92672">&amp;</span>
结果1:        <span style="color:#f92672">:</span>0000 0000 0000 0000 0000 0000 1011 <span style="color:#75715e">// 十进制:11
</span><span style="color:#75715e"></span>结果2:        <span style="color:#f92672">:</span>0000 0000 0000 0000 0000 0000 1011 <span style="color:#75715e">// 十进制:11
</span><span style="color:#75715e">//------------------------------------------------------------
</span><span style="color:#75715e">//②扩容后:长度32  
</span><span style="color:#75715e"></span>n<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span>1 <span style="color:#75715e">//二进制:0000 0000 0000 0000 0000 0001 1111
</span><span style="color:#75715e"></span>hash1 <span style="color:#75715e">//     :1101 1001 0100 1000 0110 1001 1011
</span><span style="color:#75715e"></span>hash2 <span style="color:#75715e">//     :1101 1001 0100 1000 0110 1000 1011
</span><span style="color:#75715e"></span><span style="color:#f92672">&amp;</span>
结果1:        <span style="color:#f92672">:</span>0000 0000 0000 0000 0000 0001 1011 <span style="color:#75715e">// 十进制:27
</span><span style="color:#75715e"></span>结果2:        <span style="color:#f92672">:</span>0000 0000 0000 0000 0000 0000 1011 <span style="color:#75715e">// 十进制:11
</span><span style="color:#75715e">//============================================================
</span><span style="color:#75715e">//③
</span><span style="color:#75715e"></span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> oldCap <span style="color:#f92672">==</span> 0
n<span style="color:#f92672">=</span>16  <span style="color:#75715e">//二进制:0000 0000 0000 0000 0000 0001 0000
</span><span style="color:#75715e"></span>hash1 <span style="color:#75715e">//     :1101 1001 0100 1000 0110 1001 1011
</span><span style="color:#75715e"></span>hash2 <span style="color:#75715e">//     :1101 1001 0100 1000 0110 1000 1011
</span><span style="color:#75715e"></span><span style="color:#f92672">&amp;</span>
结果1:        <span style="color:#f92672">:</span>0000 0000 0000 0000 0000 0001 0000 
结果2:        <span style="color:#f92672">:</span>0000 0000 0000 0000 0000 0000 0000 
  
<span style="color:#75715e">/*
</span><span style="color:#75715e"> * 可以看出.用旧的hash值&amp;旧的容量 算出来hash2=0.保存到原来的索引位置,hash1 按照上面长度为32的方式计算索引在27的位置
</span><span style="color:#75715e"> * 27=11+16  新位置的下标=老位置的下标+老tab的容量 
</span><span style="color:#75715e"> * 只能说这个作者太高明了...通过这种巧妙的方式避免了需重新计算hash,从而提高了效率
</span><span style="color:#75715e"> */</span>
</code></pre></div><p><strong>所以:扩容之后,要么就是原来索引的位置,要么是原来索引+老数组的容量.</strong></p>
<p><strong>备注:jdk8之前,是重新计算hash的方式进行分组,这是jdk8之后的优化</strong></p>
<h4 id="get方法">get方法</h4>
<p>HashMap 查找很简单</p>
<ol>
<li>定位桶位置</li>
<li>从链表或者红黑树中查找即可</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  	Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
  	<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> getNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getNode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  			<span style="color:#75715e">//定义了一些临时变量
</span><span style="color:#75715e"></span>        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> first<span style="color:#f92672">,</span> e<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span> K k<span style="color:#f92672">;</span>
  			<span style="color:#75715e">// 判断 tab不是null,并且链表中的头元素不是null
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span>
            <span style="color:#f92672">(</span>first <span style="color:#f92672">=</span> tab<span style="color:#f92672">[(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">//判断第一个元素的hash==查询的hash 并且 key是否相等.如果相等就直接返回
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span> <span style="color:#75715e">// always check first node
</span><span style="color:#75715e"></span>                <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                <span style="color:#66d9ef">return</span> first<span style="color:#f92672">;</span>
          <span style="color:#75715e">//否则就需要遍历
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">//判断节点是否是红黑树,是的话从树中查询
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>first <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>first<span style="color:#f92672">).</span><span style="color:#a6e22e">getTreeNode</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
              <span style="color:#75715e">//遍历,直到找到就返回
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                        <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                        <span style="color:#66d9ef">return</span> e<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="remove-方法">remove 方法</h4>
<p>HashMap 的删除操作并不复杂</p>
<ol>
<li>定位桶位置</li>
<li>遍历链表并找到键值相等的节点</li>
<li>删除节点</li>
</ol>
<p>达到退化阈值,树-&gt;链表</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> removeNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">removeNode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> Object key<span style="color:#f92672">,</span> Object value<span style="color:#f92672">,</span>
                               <span style="color:#66d9ef">boolean</span> matchValue<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> movable<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> index<span style="color:#f92672">;</span>
  			<span style="color:#75715e">// 定位桶位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span>
            <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>index <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> e<span style="color:#f92672">;</span> K k<span style="color:#f92672">;</span> V v<span style="color:#f92672">;</span>
          <span style="color:#75715e">// 如果键的值与链表第一个节点相等，则将 node 指向该节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                node <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
                    node <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>p<span style="color:#f92672">).</span><span style="color:#a6e22e">getTreeNode</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                  <span style="color:#75715e">// 2. 遍历链表，找到待删除节点
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                            <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span>
                             <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
                            node <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                        p <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
          <span style="color:#75715e">// // 3. 删除节点，并修复链表或红黑树
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(!</span>matchValue <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> value <span style="color:#f92672">||</span>
                                 <span style="color:#f92672">(</span>value <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> value<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
                    <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>node<span style="color:#f92672">).</span><span style="color:#a6e22e">removeTreeNode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> tab<span style="color:#f92672">,</span> movable<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">==</span> p<span style="color:#f92672">)</span>
                    tab<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">else</span>
                    p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
                <span style="color:#f92672">--</span>size<span style="color:#f92672">;</span>
                afterNodeRemoval<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>关于jdk 7 和 jdk8的区别 在这里总结一下,面试也经常被问到</p>
<ol>
<li>Jdk7 数组+链表,8中+红黑树</li>
<li>,jdk7hash算法为了提高散列性,比较复杂,jdk8 加入了红黑树,提高了遍历的效率,hash算法也有所简化</li>
<li>jdk7 是头插法,8是尾插法</li>
<li>jdk8扩容机制优化:
<ul>
<li>无须重新计算hash</li>
<li>顺序拷贝,不会产生死锁</li>
</ul>
</li>
</ol>
<h2 id="最后">最后</h2>
<p>花了快一周时间,差不多写完了&hellip;关于操作红黑树的部分,以后再补上吧&hellip;</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
