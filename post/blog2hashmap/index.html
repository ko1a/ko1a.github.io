<!doctype html>
<html lang="en-us">
  <head>
    <title>手撕HashMap // 阿强的blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="wangqiang" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://ko1a.github.io/css/main.min.4c1a909e6fe10d8fe1d9033af603c9b9a7803efa8046860032882a48f84a40f1.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="手撕HashMap"/>
<meta name="twitter:description" content="概述 今天我们来聊聊,我们日常开发中最常用的一个集合类:HashMap,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.
 一、基础知识   数组
数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.
优点:
 可以保存若干个数据 随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。  缺点:
 数组的元素的类型必须一致 数组定长，不能自动扩容 删除元素、插入元素效率比较低，需要移动大量的元素    链表
链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址
图是单链表
优点:
 任意加减元素 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可 添加，删除效率高  缺点:
 因为含有大量的指针域，占用空间较大 查找元素需要遍历链表来查找    散列表
散列表结构基于 数组&#43;链表 ,整合了数组的快速索引和链表的动态扩容的优势
  什么是哈希(hash)
hash 也成散列,哈希,基本原理就是把任意长度的输入,通过hash算法变成固定长度的输出.这个映射规则就是对应的hash算法,原始数据映射后的二进制串就是哈希值(hashCode)
特点:
  从hash值不能反向推导出原始数据
  输入的数据微小变化会得到完全不同的hash值,相同的数据会得到相同的hash值
  hash算法的执行效率高,长文本也能快速计算hash值
  hash算法的冲突概率要小
   hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间
比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理
  二、底层原理 三、手撕源码 "/>

    <meta property="og:title" content="手撕HashMap" />
<meta property="og:description" content="概述 今天我们来聊聊,我们日常开发中最常用的一个集合类:HashMap,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.
 一、基础知识   数组
数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.
优点:
 可以保存若干个数据 随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。  缺点:
 数组的元素的类型必须一致 数组定长，不能自动扩容 删除元素、插入元素效率比较低，需要移动大量的元素    链表
链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址
图是单链表
优点:
 任意加减元素 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可 添加，删除效率高  缺点:
 因为含有大量的指针域，占用空间较大 查找元素需要遍历链表来查找    散列表
散列表结构基于 数组&#43;链表 ,整合了数组的快速索引和链表的动态扩容的优势
  什么是哈希(hash)
hash 也成散列,哈希,基本原理就是把任意长度的输入,通过hash算法变成固定长度的输出.这个映射规则就是对应的hash算法,原始数据映射后的二进制串就是哈希值(hashCode)
特点:
  从hash值不能反向推导出原始数据
  输入的数据微小变化会得到完全不同的hash值,相同的数据会得到相同的hash值
  hash算法的执行效率高,长文本也能快速计算hash值
  hash算法的冲突概率要小
   hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间
比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理
  二、底层原理 三、手撕源码 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ko1a.github.io/post/blog2hashmap/" />
<meta property="article:published_time" content="2020-06-19T13:20:17+08:00" />
<meta property="article:modified_time" content="2020-06-19T13:20:17+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://ko1a.github.io/"><img class="app-header-avatar" src="https://pic4.zhimg.com/80/v2-2f47aaadf2eef73c77a4497a67181854_1440w.jpg?source=1940ef5c" alt="wangqiang" /></a>
      <h1>阿强的blog</h1>
      <p>go for it</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">手撕HashMap</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 19, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://ko1a.github.io/tags/java/">java</a>
              <a class="tag" href="https://ko1a.github.io/tags/hashmap/">hashMap</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="概述">概述</h2>
<p>今天我们来聊聊,我们日常开发中最常用的一个集合类:<!-- raw HTML omitted -->HashMap<!-- raw HTML omitted -->,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.</p>
<p> </p>
<h3 id="一基础知识">一、基础知识</h3>
<ol>
<li>
<p><strong>数组</strong></p>
<p>数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.</p>
<p><img src="/images/image-20210221153520150.png" alt=""></p>
<p><strong>优点</strong>:</p>
<ul>
<li>可以保存若干个数据</li>
<li>随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>数组的元素的类型必须一致</li>
<li>数组定长，不能自动扩容</li>
<li>删除元素、插入元素效率比较低，需要移动大量的元素</li>
</ul>
</li>
<li>
<p><strong>链表</strong></p>
<p>链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址</p>
<p>图是单链表</p>
<p><img src="/images/image-20210221160024293.png" alt="image-20210221160024293"></p>
<p><strong>优点</strong>:</p>
<ul>
<li>任意加减元素</li>
<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可</li>
<li>添加，删除效率高</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>因为含有大量的指针域，占用空间较大</li>
<li>查找元素需要遍历链表来查找</li>
</ul>
</li>
<li>
<p><strong>散列表</strong></p>
<p>散列表结构基于 数组+链表 ,整合了数组的快速索引和链表的动态扩容的优势</p>
<p><img src="/images/image-20210221160945491.png" alt=""></p>
</li>
<li>
<p><strong>什么是哈希(hash)</strong></p>
<p>hash 也成散列,哈希,基本原理就是把<!-- raw HTML omitted --><strong>任意长度</strong><!-- raw HTML omitted -->的输入,通过hash算法变成<!-- raw HTML omitted --><strong>固定长度</strong><!-- raw HTML omitted -->的输出.这个映射规则就是对应的<!-- raw HTML omitted --><strong>hash算法</strong><!-- raw HTML omitted -->,原始数据映射后的<!-- raw HTML omitted --><strong>二进制串</strong><!-- raw HTML omitted -->就是哈希值(hashCode)</p>
<p><strong>特点</strong>:</p>
<ul>
<li>
<p>从hash值不能<!-- raw HTML omitted --><strong>反向推导</strong><!-- raw HTML omitted -->出原始数据</p>
</li>
<li>
<p>输入的数据<!-- raw HTML omitted --><strong>微小变化</strong><!-- raw HTML omitted -->会得到完全不同的hash值,相同的数据会得到相同的hash值</p>
</li>
<li>
<p>hash算法的执行效率高,长文本也能快速计算hash值</p>
</li>
<li>
<p>hash算法的冲突概率要小</p>
<p> </p>
</li>
</ul>
<p>hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间</p>
<p>比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理</p>
</li>
</ol>
<h3 id="二底层原理">二、底层原理</h3>
<h3 id="三手撕源码">三、手撕源码</h3>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
