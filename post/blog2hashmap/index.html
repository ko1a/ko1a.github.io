<!doctype html>
<html lang="en-us">
  <head>
    <title>手撕HashMap(Jdk8) // 阿强的blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="wangqiang" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://ko1a.github.io/css/main.min.4c1a909e6fe10d8fe1d9033af603c9b9a7803efa8046860032882a48f84a40f1.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="手撕HashMap(Jdk8)"/>
<meta name="twitter:description" content="概述 今天我们来聊聊,我们日常开发中最常用的一个集合类:HashMap,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.
 一、基础知识   数组
数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.
优点:
 可以保存若干个数据 随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。  缺点:
 数组的元素的类型必须一致 数组定长，不能自动扩容 删除元素、插入元素效率比较低，需要移动大量的元素    链表
链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址
图是单链表
优点:
 任意加减元素 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可 添加，删除效率高  缺点:
 因为含有大量的指针域，占用空间较大 查找元素需要遍历链表来查找    散列表
散列表结构基于 数组&#43;链表 ,整合了数组的快速索引和链表的动态扩容的优势
  什么是哈希(hash)
hash 也成散列,哈希,基本原理就是把任意长度的输入,通过hash算法变成固定长度的输出.这个映射规则就是对应的hash算法,原始数据映射后的二进制串就是哈希值(hashCode)
特点:
  从hash值不能反向推导出原始数据
  输入的数据微小变化会得到完全不同的hash值,相同的数据会得到相同的hash值
  hash算法的执行效率高,长文本也能快速计算hash值
  hash算法的冲突概率要小
   hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间
比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理
  二、基本原理 存储结构 结构实现来讲，HashMap是数组&#43;链表&#43;红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。
HashMap 使用拉链式的散列算法,其数据结构是由数组和链表（或树形结构）组成。"/>

    <meta property="og:title" content="手撕HashMap(Jdk8)" />
<meta property="og:description" content="概述 今天我们来聊聊,我们日常开发中最常用的一个集合类:HashMap,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.
 一、基础知识   数组
数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.
优点:
 可以保存若干个数据 随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。  缺点:
 数组的元素的类型必须一致 数组定长，不能自动扩容 删除元素、插入元素效率比较低，需要移动大量的元素    链表
链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址
图是单链表
优点:
 任意加减元素 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可 添加，删除效率高  缺点:
 因为含有大量的指针域，占用空间较大 查找元素需要遍历链表来查找    散列表
散列表结构基于 数组&#43;链表 ,整合了数组的快速索引和链表的动态扩容的优势
  什么是哈希(hash)
hash 也成散列,哈希,基本原理就是把任意长度的输入,通过hash算法变成固定长度的输出.这个映射规则就是对应的hash算法,原始数据映射后的二进制串就是哈希值(hashCode)
特点:
  从hash值不能反向推导出原始数据
  输入的数据微小变化会得到完全不同的hash值,相同的数据会得到相同的hash值
  hash算法的执行效率高,长文本也能快速计算hash值
  hash算法的冲突概率要小
   hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间
比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:抽屉原理
  二、基本原理 存储结构 结构实现来讲，HashMap是数组&#43;链表&#43;红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。
HashMap 使用拉链式的散列算法,其数据结构是由数组和链表（或树形结构）组成。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ko1a.github.io/post/blog2hashmap/" />
<meta property="article:published_time" content="2020-06-19T13:20:17+08:00" />
<meta property="article:modified_time" content="2020-06-19T13:20:17+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://ko1a.github.io/"><img class="app-header-avatar" src="https://pic4.zhimg.com/80/v2-2f47aaadf2eef73c77a4497a67181854_1440w.jpg?source=1940ef5c" alt="wangqiang" /></a>
      <h1>阿强的blog</h1>
      <p>go for it</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">手撕HashMap(Jdk8)</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 19, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          6 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://ko1a.github.io/tags/java/">java</a>
              <a class="tag" href="https://ko1a.github.io/tags/hashmap/">hashMap</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="概述">概述</h2>
<p>今天我们来聊聊,我们日常开发中最常用的一个集合类:<!-- raw HTML omitted -->HashMap<!-- raw HTML omitted -->,在我们面试中也会被经常问到相关问题,由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，那么本文会分成三个部分来透彻的对HashMap进行分析.</p>
<p> </p>
<h3 id="一基础知识">一、基础知识</h3>
<ol>
<li>
<p><strong>数组</strong></p>
<p>数组是在内存中存储相同数据类型的连续的空间,每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们.</p>
<p><img src="/images/image-20210221153520150.png" alt=""></p>
<p><strong>优点</strong>:</p>
<ul>
<li>可以保存若干个数据</li>
<li>随机访问的效率很高。根据下标访问元素效率高（元素连续分配空间）。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>数组的元素的类型必须一致</li>
<li>数组定长，不能自动扩容</li>
<li>删除元素、插入元素效率比较低，需要移动大量的元素</li>
</ul>
</li>
<li>
<p><strong>链表</strong></p>
<p>链表在内存中不是连续的空间,每一块空间有一块引用保存下一块内存的地址</p>
<p>图是单链表</p>
<p><img src="/images/image-20210221160024293.png" alt="image-20210221160024293"></p>
<p><strong>优点</strong>:</p>
<ul>
<li>任意加减元素</li>
<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可</li>
<li>添加，删除效率高</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>因为含有大量的指针域，占用空间较大</li>
<li>查找元素需要遍历链表来查找</li>
</ul>
</li>
<li>
<p><strong>散列表</strong></p>
<p>散列表结构基于 数组+链表 ,整合了数组的快速索引和链表的动态扩容的优势</p>
<p><img src="/images/image-20210221160945491.png" alt=""></p>
</li>
<li>
<p><strong>什么是哈希(hash)</strong></p>
<p>hash 也成散列,哈希,基本原理就是把<!-- raw HTML omitted --><strong>任意长度</strong><!-- raw HTML omitted -->的输入,通过hash算法变成<!-- raw HTML omitted --><strong>固定长度</strong><!-- raw HTML omitted -->的输出.这个映射规则就是对应的<!-- raw HTML omitted --><strong>hash算法</strong><!-- raw HTML omitted -->,原始数据映射后的<!-- raw HTML omitted --><strong>二进制串</strong><!-- raw HTML omitted -->就是哈希值(hashCode)</p>
<p><strong>特点</strong>:</p>
<ul>
<li>
<p>从hash值不能<!-- raw HTML omitted --><strong>反向推导</strong><!-- raw HTML omitted -->出原始数据</p>
</li>
<li>
<p>输入的数据<!-- raw HTML omitted --><strong>微小变化</strong><!-- raw HTML omitted -->会得到完全不同的hash值,相同的数据会得到相同的hash值</p>
</li>
<li>
<p>hash算法的执行效率高,长文本也能快速计算hash值</p>
</li>
<li>
<p>hash算法的冲突概率要小</p>
<p> </p>
</li>
</ul>
<p>hash碰撞:由于hash原理是将输入空间的值映射成hash空间内,并且hash值得空间远小于输入的空间</p>
<p>比如:桌上十个苹果,放到九个抽屉里面,无论如何都会重复.这一现象称为:<strong>抽屉原理</strong></p>
</li>
</ol>
<h3 id="二基本原理">二、基本原理</h3>
<h4 id="存储结构">存储结构</h4>
<p>结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="/images/3169099812-5a65971be70a6_articlex.png" alt="img"></p>
<p>HashMap 使用拉链式的散列算法,其数据结构是由数组和链表（或树形结构）组成。</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部(JDK1.7是采用头插法,插在头部)。</p>
<p>当一个链表的元素个数达到一定的数量且数组的长度达到一定的长度后，则把链表转化为红黑树。</p>
<h3 id="三源码分析">三、源码分析</h3>
<p>打开<code>HashMap.java</code> 来瞧一瞧</p>
<h4 id="类成员">类成员</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> AbstractMap<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;,</span> Cloneable<span style="color:#f92672">,</span> Serializable <span style="color:#f92672">{</span>
	<span style="color:#75715e">/**
</span><span style="color:#75715e">     *	默认的初始化容量16,hashMap的容量必须是2的次方数.
</span><span style="color:#75715e">     *	1&lt;&lt;4=16  这里是0000 0001 左移4位变成0001 0000 转换成十进制等于16 (看不懂的请先看我另外&lt;&lt;java位运算&gt;&gt;这篇文章)
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_INITIAL_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 4<span style="color:#f92672">;</span> <span style="color:#75715e">// aka 16
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	最大的容量为2的30次方  
</span><span style="color:#75715e">     *	算了一下是:1073741824
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAXIMUM_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 30<span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	默认负载因子
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> DEFAULT_LOAD_FACTOR <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">75f</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	链表转成红黑树的阈值(条件1)
</span><span style="color:#75715e">     *	hash碰撞之后,形成链表,当链表长度超过这个值得时候,有可能进行链表到红黑树的转变
</span><span style="color:#75715e">     *	转换成红黑树必须要满足两个条件
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TREEIFY_THRESHOLD <span style="color:#f92672">=</span> 8<span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	红黑树转为链表的阈值。
</span><span style="color:#75715e">     * 	比如:在删除某些元素之后,扩容时如果发现链表长度(桶中元素个数)小于 6，则会由红黑树重新退化为链表
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> UNTREEIFY_THRESHOLD <span style="color:#f92672">=</span> 6<span style="color:#f92672">;</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *	最小树化容量阈值(条件2)
</span><span style="color:#75715e">     *	当哈希表中的容量(数组的长度) &gt; 该值时，才允许树形化链表,否则，若桶内元素太多时，则直接扩容，而不是树形化
</span><span style="color:#75715e">     *	为了避免进行扩容和树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
</span><span style="color:#75715e">     *	转换成红黑树必须要满足两个条件
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MIN_TREEIFY_CAPACITY <span style="color:#f92672">=</span> 64<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Node 是 hashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射 (键值对)
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">;</span> <span style="color:#75715e">// 用来定位数组索引位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">final</span> K key<span style="color:#f92672">;</span>
        V value<span style="color:#f92672">;</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span> <span style="color:#75715e">// 链表的下一个node
</span><span style="color:#75715e"></span>
        Node<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> K <span style="color:#a6e22e">getKey</span><span style="color:#f92672">()</span>        <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span>      <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>V newValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
		<span style="color:#75715e">/**
</span><span style="color:#75715e">     * 哈希桶数组，分配的时候，table的长度总是2的次方数
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> table<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * HashMap 中实际存储的 key-value 键值对数量
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败机制
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> modCount<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * HashMap 扩容阈值，当数量&gt;=threshold时，就会扩容
</span><span style="color:#75715e">     * 计算方法：容量capacity * 负载因子load factor    
</span><span style="color:#75715e">     * 比如:默认容量16*0.75=12,当map中的元素&gt;=12 就会触发扩容
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * HashMap 的负载因子.作用是为了计算扩容阈值
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="构造方法">构造方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法1:定了具体容量大小和加载因子的构造函数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  	<span style="color:#75715e">//校验:传入的初始化容量参数不能&lt;0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal initial capacity: &#34;</span> <span style="color:#f92672">+</span>
                                         initialCapacity<span style="color:#f92672">);</span>
  	<span style="color:#75715e">//校验:如果传入的初始化容量参数&gt;MAXIMUM_CAPACITY最大容量值,就把最大值赋值给初始化容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&gt;</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span>
      initialCapacity <span style="color:#f92672">=</span> MAXIMUM_CAPACITY<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//校验:负载因子不能&lt;=0 并且 它不能是个非数值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>loadFactor <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">||</span> Float<span style="color:#f92672">.</span><span style="color:#a6e22e">isNaN</span><span style="color:#f92672">(</span>loadFactor<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal load factor: &#34;</span> <span style="color:#f92672">+</span>
                                         loadFactor<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> loadFactor<span style="color:#f92672">;</span>
  	<span style="color:#75715e">//这个方法下面会讲到
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">threshold</span> <span style="color:#f92672">=</span> tableSizeFor<span style="color:#f92672">(</span>initialCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法2:指定了具体容量大小的构造函数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  	<span style="color:#75715e">//调用上面那个方法,传入的是默认负载因子
</span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>initialCapacity<span style="color:#f92672">,</span> DEFAULT_LOAD_FACTOR<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法3:默认无参构造
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> DEFAULT_LOAD_FACTOR<span style="color:#f92672">;</span> <span style="color:#75715e">// all other fields defaulted
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 构造方法4:指定map
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">(</span>Map<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> K<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> V<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> DEFAULT_LOAD_FACTOR<span style="color:#f92672">;</span>
    putMapEntries<span style="color:#f92672">(</span>m<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="tablesizefor">tableSizeFor</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Returns a power of two size for the given target capacity.
</span><span style="color:#75715e"> * 计算出 &gt;=cap的最小的2的次方数
</span><span style="color:#75715e"> * 例如:cap=10 ,那么最接近10的2的次方数是16
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tableSizeFor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> cap<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> cap <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 8<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> MAXIMUM_CAPACITY <span style="color:#f92672">:</span> n <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>


</code></pre></div><p>这里看不懂的请看我的另外一片文章:<a href="https://ko1a.github.io/post/bitoperationblog/">&laquo;Java中位运算&raquo;</a></p>
<p>举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>		<span style="color:#75715e">//10的二进制:0000 0000 0000 0000 0000 0000 0000 1010
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 10 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>	<span style="color:#75715e">//9的二进制: 0000 0000 0000 0000 0000 0000 0000 1001
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">;</span> 
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1001&gt;&gt;&gt;1等于0000 0000 0000 0000 0000 0000 0000 0100 
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1001 | 0000 0000 0000 0000 0000 0000 0000 0100
</span><span style="color:#75715e">//		n=0000 0000 0000 0000 0000 0000 0000 1101
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1101&gt;&gt;&gt;2等于0000 0000 0000 0000 0000 0000 0000 0011
</span><span style="color:#75715e">//第二步:0000 0000 0000 0000 0000 0000 0000 1101 | 0000 0000 0000 0000 0000 0000 0000 0011
</span><span style="color:#75715e">//		n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1111&gt;&gt;&gt;4等于0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e">//右移4位还是1111
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 8<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1111&gt;&gt;&gt;8等于0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e">//右移8位还是1111
</span><span style="color:#75715e"></span>n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">;</span>
<span style="color:#75715e">//第一步:0000 0000 0000 0000 0000 0000 0000 1111&gt;&gt;&gt;16等于0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//第二部:0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 0000
</span><span style="color:#75715e">//n=0000 0000 0000 0000 0000 0000 0000 1111
</span><span style="color:#75715e">//右移16位还是1111
</span><span style="color:#75715e">//1111转出十进制就是15
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//如果计算出来n&lt;最大容量 n+1
</span><span style="color:#75715e">//n=15+1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> MAXIMUM_CAPACITY <span style="color:#f92672">:</span> n <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>



</code></pre></div><p>最后 <code>int n = cap - 1;</code> 这个是为了你传入的cap就是2的次方数.</p>
<p>例如8 那么算出来的结果就会是16. 那么就翻了一倍&hellip;可以自己尝试一下就明白了</p>
<h4 id="put方法">put方法</h4>
<p>虽然插入的入口是put, 但是核心逻辑在putVal 里面</p>
<p>源码↓↓↓</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> putVal<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 扰动函数:更新新数据的key 先 hashCode 在将hash值进行右移16位后 再与原hash值 进行异或操作 
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> h<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">())</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * int hash key计算出来的hash值
</span><span style="color:#75715e"> * K key 
</span><span style="color:#75715e"> * V value
</span><span style="color:#75715e"> * boolean onlyIfAbsent 是否覆盖
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">,</span>
                   <span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  			<span style="color:#75715e">//临时变量 
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//tab 当前散列表
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//p	待插入位置的元素
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//n hash 数组的长度
</span><span style="color:#75715e"></span>  			<span style="color:#75715e">//i 插入元素在数组中的下标位置
</span><span style="color:#75715e"></span>        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">;</span>
  			<span style="color:#75715e">//先赋值,然后判断hashMap是否是空,如果是,调用resize()方法扩容.懒加载机制
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
            n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> resize<span style="color:#f92672">()).</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
  
        <span style="color:#75715e">/**
</span><span style="color:#75715e">        * ①:i = (n - 1) &amp; hash 计算出新数据插入位置的下标,赋值给i
</span><span style="color:#75715e">        * ②:将i的位置的数据,赋值给p
</span><span style="color:#75715e">        *	③:判断p是否为null,如果是null ,则直接插入
</span><span style="color:#75715e">        */</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            tab<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
  			<span style="color:#75715e">//否则p不为null的情况
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
          	<span style="color:#75715e">//先定义临时变量,e,k
</span><span style="color:#75715e"></span>            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span> K k<span style="color:#f92672">;</span>
          	<span style="color:#75715e">//判断p的hash是否是新数据的hash 并且 key是否相等,如果是,就把p赋值给e
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                e <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
          	<span style="color:#75715e">//判断p是否是红黑树,如果是,就走插入红黑树的逻辑
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
                e <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>p<span style="color:#f92672">).</span><span style="color:#a6e22e">putTreeVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> tab<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
          	<span style="color:#75715e">//否则,p不等于要插入的新元素,就开始拉链插入
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">//循环
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> binCount <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> <span style="color:#f92672">;</span> <span style="color:#f92672">++</span>binCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                  <span style="color:#75715e">//将p.next节点赋值给e,并判断是否为空,是直接插入,
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                      <span style="color:#75715e">//判断链表的长度&gt;树化的阈值,就有可能树化转红黑树,treeifyBin方法里面会判断数组长度是否&gt;=64,
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">&gt;=</span> TREEIFY_THRESHOLD <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#75715e">// -1 for 1st
</span><span style="color:#75715e"></span>                            treeifyBin<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> hash<span style="color:#f92672">);</span>
                        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                  <span style="color:#75715e">//如果e跟新元素是一样就直接break
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                        <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                    p <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
          <span style="color:#75715e">//e不等于null,就替换操作,返回老数据
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// existing mapping for key
</span><span style="color:#75715e"></span>                V oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent <span style="color:#f92672">||</span> oldValue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                afterNodeAccess<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
  			<span style="color:#75715e">// 更新内部结构发生变化的次数
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
  			<span style="color:#75715e">// 判断 自增后的桶的大小&gt;扩容阈值,则扩容
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>size <span style="color:#f92672">&gt;</span> threshold<span style="color:#f92672">)</span>
            resize<span style="color:#f92672">();</span>
        afterNodeInsertion<span style="color:#f92672">(</span>evict<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p><strong>插入逻辑分析:</strong></p>
<ol>
<li><strong>先判断hashMap是否为null,是的话,就进行初始化操作(懒加载)</strong></li>
<li><strong>计算插入位置的下标,判断为null,如果是null就直接插入</strong></li>
<li><strong>判断插入位置的引用是否是红黑树,如果是就走红黑树插入逻辑</strong></li>
<li><strong>循环链表,判断链表长度是否达到树化阈值,若果达到,继续判断数组长度是否大于64,两个判断同时成立,转换成红黑树,否则继续扩容,判断插入数据是否相等则替换,否则将其插入尾部(jdk7是采用头插法)</strong></li>
<li><strong>更新内部结构发生变化的次数和判断是否扩容.</strong></li>
</ol>
<p>几个细节分析:</p>
<p>① 在计算hash,这里为什么要先后移16位,再进行异或操作?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">())</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">)</span>
</code></pre></div><p>举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">h<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span> <span style="color:#f92672">=</span>    1010 0100 1101 1110 0101 1011 1011 0001
h<span style="color:#f92672">=</span>              1010 0101 1101 1110 0101 1011 1011 0001
h<span style="color:#f92672">&gt;&gt;&gt;</span>16 <span style="color:#f92672">=</span>        0000 0000 0000 0000 0010 0100 1101 1110
h <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">)=</span> 1010 0101 1101 1110 0111 1111 0110 1111
<span style="color:#75715e">//假设这里不右移
</span><span style="color:#75715e"></span>h<span style="color:#f92672">=</span>              1010 0101 1101 1110 0101 1011 1011 0001
h<span style="color:#f92672">^</span>h<span style="color:#f92672">=</span>            0000 0000 0000 0000 0010 0100 1101 1110
<span style="color:#75715e">//所以可以看出有什么区别吧...
</span><span style="color:#75715e"></span>
</code></pre></div><p><strong>右移16位.再进行了异或操作后,是为了让高位和低位同时参与hash计算,增加hash的复杂度.其目的就是可以提高hash的散列性,从而减少hash碰撞.</strong></p>
<p>②计算下标</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash
</code></pre></div><p>这行代码效果就是根据hash值算出来一个数组下标</p>
<p>举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//假设hash = 阿强
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;阿强&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">();</span>
<span style="color:#75715e">//假设数组的长度是16
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>
n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span><span style="color:#75715e">//n-1是因为数组下标从0开始
</span><span style="color:#75715e">// hash 转换成二进制:100101001000011011011
</span><span style="color:#75715e">// n    转换成二进制:000000000000000001111
</span><span style="color:#75715e">//进行 &amp; 操作之后结果:000000000000000001011 转换成十进制为:11
</span></code></pre></div><p><strong>因为n的高位都是0 ,&amp;操作之后,低位就和hash的低位是一样的,实际的取值范围就是低四位的取值范围.所以就是0000到1111.</strong></p>
<p><strong>可以看出其实这里就是一个取模的操作,如果数组的length不是2的次方数,用位运算计算的话,会出现不一样的结果,但是位运算效率比取模高.</strong></p>
<p>再举个栗子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> 17<span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 15<span style="color:#f92672">;</span>
n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">// hash 转换成二进制:10001
</span><span style="color:#75715e">// n    转换成二进制:01110
</span><span style="color:#75715e">// &amp;    结果:       00000
</span><span style="color:#75715e">//用十进制取余 17%15=2;
</span><span style="color:#75715e">//但是用 位运算 的结果=0
</span></code></pre></div><p><strong>所以,如果是用位运算计算,HashMap的容量一定要是2的次方数</strong></p>
<h4 id="resize-扩容方法">resize 扩容方法</h4>
<p>扩容条件:</p>
<ol>
<li>当表为null,初始化扩容</li>
<li>链表长度&gt;=8</li>
<li>hashMap的元素个数 * loadFactor 负载因子(默认0.75) &gt;=threshold 扩容阈值 发生扩容.例:16*0.75=12. 当map中的元素&gt;=12会扩容</li>
</ol>
<p>待更新&hellip;.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
